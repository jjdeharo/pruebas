<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visor de Aplicaciones Proxy</title>
    <style>
        body, html { margin: 0; padding: 0; height: 100%; width: 100%; }
        iframe { width: 100%; height: 100%; border: none; }
        #loader { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; font-family: sans-serif; color: #555; }
        #loader p { margin-top: 10px; }
    </style>
</head>
<body>
    <div id="loader"><p>Cargando...</p></div>
    <iframe id="content-frame" style="display:none;"></iframe>
    
<script>
    const API_URL = 'https://script.google.com/macros/s/AKfycbxgHrkyhcO01HnuX0uil9M7f5MDE5LXr56G4P1_4PcT82k9zpxSih8IHuedB7mcT9X4/exec';
    const iframe = document.getElementById('content-frame');
    const loader = document.getElementById('loader');
    const resourceCache = new Map();

    async function fetchFromDrive(folderId, path) {
        if (resourceCache.has(path)) {
            return resourceCache.get(path);
        }

        const url = `${API_URL}?folderId=${folderId}&path=${encodeURIComponent(path)}`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Error (${response.status}) al cargar: ${path}`);
        
        const contentType = response.headers.get('Content-Type');
        
        if (contentType && contentType.includes('application/json')) {
             const data = await response.json();
             if(data.error) throw new Error(`API Error: ${data.error.message} for path: ${path}`);
             return data;
        }

        if (contentType && contentType.includes('text/plain')) {
             const base64 = await response.text();
             const binary = atob(base64);
             const len = binary.length;
             const bytes = new Uint8Array(len);
             for(let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
             const blob = new Blob([bytes]);
             resourceCache.set(path, blob);
             return blob;
        }
        
        const textContent = await response.text();
        resourceCache.set(path, textContent);
        return textContent;
    }

    async function loadContent() {
        loader.style.display = 'flex';
        iframe.style.display = 'none';

        const hash = window.location.hash.substring(1);
        const [folderId, ...pathParts] = hash.split('/');
        let path = pathParts.join('/') || 'index.html';
        if (path.endsWith('/')) path += 'index.html';


        if (!folderId) {
            loader.innerHTML = '<p>Error: Falta el ID de la carpeta en la URL. Ejemplo: #folderId/index.html</p>';
            return;
        }

        try {
            const htmlContent = await fetchFromDrive(folderId, path);
            const doc = new DOMParser().parseFromString(htmlContent, 'text/html');
            
            const base = path.substring(0, path.lastIndexOf('/') + 1);

            const promises = [];
            doc.querySelectorAll('link[href], script[src], img[src], a[href]').forEach(el => {
                const isLink = el.tagName === 'A';
                const attr = el.getAttribute('href') || el.getAttribute('src');

                if (attr && !attr.startsWith('http') && !attr.startsWith('#') && !attr.startsWith('data:')) {
                    const absolutePath = new URL(attr, `http://dummy/${base}`).pathname.substring(1);
                    
                    if (isLink && (attr.endsWith('.html') || !attr.includes('.'))) {
                        el.href = `#${folderId}/${absolutePath}`;
                    } else if (!isLink) {
                        const promise = fetchFromDrive(folderId, absolutePath)
                            .then(blob => {
                                const blobUrl = URL.createObjectURL(blob);
                                el.setAttribute(el.hasAttribute('href') ? 'href' : 'src', blobUrl);
                            })
                            .catch(err => console.error(`Failed to load resource: ${absolutePath}`, err));
                        promises.push(promise);
                    }
                }
            });

            await Promise.all(promises);

            const finalHtml = new XMLSerializer().serializeToString(doc);
            iframe.srcdoc = finalHtml;
            loader.style.display = 'none';
            iframe.style.display = 'block';

        } catch (error) {
            loader.innerHTML = `<h2>Error al cargar el contenido</h2><p>${error.message}</p>`;
            console.error(error);
        }
    }

    window.addEventListener('hashchange', loadContent);
    window.addEventListener('load', loadContent);
</script>
</body>
</html>