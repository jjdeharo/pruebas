<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visor de Aplicaciones Proxy</title>
    <style>
        body, html { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; }
        iframe { width: 100%; height: 100%; border: none; }
        #loader { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; font-family: sans-serif; color: #555; text-align: center; padding: 20px; }
        #loader p { margin-top: 10px; word-break: break-word; }
        #loader h2 { margin: 0; }
    </style>
</head>
<body>
    <div id="loader"><p>Cargando...</p></div>
    <iframe id="content-frame" style="display:none;"></iframe>
<script>
    const API_URL = 'https://script.google.com/macros/s/AKfycbxpfrefeG14BL80vvNj-0fpN9I-cA-ri4kR0EurzaWGH6jAg6H0uy15mSmNAzop-KG4/exec';
    const iframe = document.getElementById('content-frame');
    const loader = document.getElementById('loader');
    const resourceCache = new Map();

    async function fetchFromDrive(folderId, path) {
        const cacheKey = `${folderId}/${path}`;
        if (resourceCache.has(cacheKey)) {
            return resourceCache.get(cacheKey);
        }

        const url = `${API_URL}?folderId=${folderId}&path=${encodeURIComponent(path)}`;
        const response = await fetch(url);
        
        const contentType = response.headers.get('Content-Type') || '';
        
        // CORREGIDO: Manejar JSON siempre como un posible error y mostrar su contenido.
        if (contentType.includes('application/json')) {
             const data = await response.json();
             let errorMessage;
             if (data && data.error && data.error.message) {
                errorMessage = data.error.message;
             } else {
                errorMessage = `Respuesta inesperada de la API: ${JSON.stringify(data)}`;
             }
             throw new Error(`Error en la API para el archivo '${path}': ${errorMessage}`);
        }

        if (!response.ok) {
            throw new Error(`Error de red (${response.status}) al cargar el recurso: ${path}`);
        }

        if (contentType.includes('text/plain')) {
             const base64 = await response.text();
             const binary = atob(base64);
             const len = binary.length;
             const bytes = new Uint8Array(len);
             for(let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
             const blob = new Blob([bytes]);
             resourceCache.set(cacheKey, blob);
             return blob;
        }
        
        const textContent = await response.text();
        resourceCache.set(cacheKey, textContent);
        return textContent;
    }

    async function loadContent() {
        loader.style.display = 'flex';
        iframe.style.display = 'none';

        const hash = window.location.hash.substring(1);
        const [folderId, ...pathParts] = hash.split('/');
        let path = pathParts.join('/') || 'index.html';
        if (path.endsWith('/')) path += 'index.html';

        if (!folderId) {
            loader.innerHTML = '<h2>Error de configuración</h2><p>Falta el ID de la carpeta en la URL. Ejemplo: #ID_DE_CARPETA/index.html</p>';
            return;
        }

        try {
            const htmlContent = await fetchFromDrive(folderId, path);
            // Si el contenido principal es un blob (p. ej. una imagen pedida directamente), no lo podemos procesar como HTML.
            if(htmlContent instanceof Blob) {
                throw new Error("La ruta principal no es un archivo HTML válido.")
            }
            const doc = new DOMParser().parseFromString(htmlContent, 'text/html');
            
            const base = path.substring(0, path.lastIndexOf('/') + 1);

            const promises = [];
            doc.querySelectorAll('link[href], script[src], img[src], a[href]').forEach(el => {
                const isLink = el.tagName === 'A';
                const attr = el.getAttribute('href') || el.getAttribute('src');

                if (attr && !attr.startsWith('http') && !attr.startsWith('#') && !attr.startsWith('data:') && !attr.startsWith('blob:')) {
                    const absolutePath = new URL(attr, `http://dummy.com/${base}`).pathname.substring(1);
                    
                    if (isLink && (attr.endsWith('.html') || !attr.includes('.'))) {
                        el.href = `#${folderId}/${absolutePath}`;
                    } else if (!isLink) {
                        const promise = fetchFromDrive(folderId, absolutePath)
                            .then(blob => {
                                const blobUrl = URL.createObjectURL(blob);
// Simbolo del dolar que estaba causando problemas quitado.
                                el.setAttribute(el.hasAttribute('href') ? 'href' : 'src', blobUrl);
                            });
                        promises.push(promise);
                    }
                }
            });

            await Promise.all(promises);

            const finalHtml = new XMLSerializer().serializeToString(doc);
            iframe.srcdoc = finalHtml;
            loader.style.display = 'none';
            iframe.style.display = 'block';

        } catch (error) {
            loader.innerHTML = `<h2>Error al cargar el contenido</h2><p>${error.message}</p>`;
            console.error(error);
        }
    }

    window.addEventListener('hashchange', loadContent);
    window.addEventListener('load', loadContent);
</script>
</body>
</html>