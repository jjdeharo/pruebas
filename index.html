<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visor de Aplicaciones Proxy</title>
    <style>
        body, html { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; }
        iframe { width: 100%; height: 100%; border: none; }
        #loader { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; font-family: sans-serif; color: #555; text-align: center; padding: 20px; }
        #loader p { margin-top: 10px; word-break: break-word; }
        #loader h2 { margin: 0; }
    </style>
</head>
<body>
    <div id="loader"><p>Cargando...</p></div>
    <iframe id="content-frame" style="display:none;"></iframe>
<script>
    const API_URL = 'https://script.google.com/macros/s/AKfycbxcD7gjU_VdT0E_qYvWNHr3CCmThGYQ3k9dWiRRsrYJzJW04qf0IYtyfx85mgTbeNZ8/exec';
    const iframe = document.getElementById('content-frame');
    const loader = document.getElementById('loader');
    const resourceCache = new Map();

    // Función para convertir Base64 a Blob
    function base64ToBlob(base64, mimeType) {
        const byteCharacters = atob(base64);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        return new Blob([byteArray], {type: mimeType});
    }

    async function fetchFromDrive(folderId, path) {
        const cacheKey = `${folderId}/${path}`;
        if (resourceCache.has(cacheKey)) {
            return resourceCache.get(cacheKey);
        }

        const url = `${API_URL}?folderId=${folderId}&path=${encodeURIComponent(path)}&cacheBust=${Date.now()}`;
        const response = await fetch(url, { cache: 'no-store' });

        if (!response.ok) {
            throw new Error(`Error de red (${response.status}) al contactar la API.`);
        }
        
        const data = await response.json();

        if (!data.success) {
            throw new Error(data.error || 'Error desconocido en la API.');
        }

        if (data.encoding === 'base64') {
            const blob = base64ToBlob(data.content, data.mimeType);
            resourceCache.set(cacheKey, blob);
            return blob;
        } else {
            resourceCache.set(cacheKey, data.content);
            return data.content;
        }
    }

    async function loadContent() {
        loader.style.display = 'flex';
        iframe.style.display = 'none';

        const hash = window.location.hash.substring(1);
        if (!hash) {
            loader.innerHTML = '<h2>Bienvenido</h2><p>Añade el ID de una carpeta de Drive a la URL para empezar. Ejemplo: #ID_DE_CARPETA</p>';
            return;
        }
        
        const pathParts = hash.split('/');
        const folderId = pathParts.shift();
        let path = pathParts.join('/') || 'index.html';
        if(path.endsWith('/')) path += 'index.html';


        if (!folderId) {
            loader.innerHTML = '<h2>Error de configuración</h2><p>URL inválida. El formato es #ID_DE_CARPETA/ruta/al/archivo.html</p>';
            return;
        }

        try {
            const htmlContent = await fetchFromDrive(folderId, path);
            if(htmlContent instanceof Blob) {
                throw new Error("La ruta principal (" + path + ") no es un archivo HTML válido.")
            }
            const doc = new DOMParser().parseFromString(htmlContent, 'text/html');
            
            const base = path.substring(0, path.lastIndexOf('/') + 1);

            const promises = [];
            doc.querySelectorAll('link[href], script[src], img[src], a[href]').forEach(el => {
                const isLink = el.tagName === 'A';
                const attr = el.hasAttribute('href') ? 'href' : 'src';
                const originalUrl = el.getAttribute(attr);

                if (originalUrl && !originalUrl.startsWith('http') && !originalUrl.startsWith('#') && !originalUrl.startsWith('data:') && !originalUrl.startsWith('blob:')) {
                    
                    const absolutePath = new URL(originalUrl, `http://dummy.com/${base}`).pathname.substring(1);
                    
                    if (isLink && (originalUrl.endsWith('.html') || !originalUrl.includes('.'))) {
                        el.href = `#${folderId}/${absolutePath}`;
                    } else if (!isLink) {
                        const promise = fetchFromDrive(folderId, absolutePath)
                            .then(blob => {
                                const blobUrl = URL.createObjectURL(blob);
                                el.setAttribute(attr, blobUrl);
                            }).catch(err => {
                                console.error(`No se pudo cargar el recurso: ${absolutePath}`, err);
                            });
                        promises.push(promise);
                    }
                }
            });

            await Promise.all(promises);

            const finalHtml = new XMLSerializer().serializeToString(doc);
            iframe.srcdoc = finalHtml;
            loader.style.display = 'none';
            iframe.style.display = 'block';

        } catch (error) {
            loader.innerHTML = `<h2>Error al cargar el contenido</h2><p>${error.message}</p>`;
            console.error(error);
        }
    }

    window.addEventListener('hashchange', loadContent);
    window.addEventListener('load', loadContent);
</script>
</body>
</html>